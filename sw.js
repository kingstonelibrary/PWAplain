var __wpo = {
  assets: {
    main: [
      "./img/tris-package.svg",
      "./icons/apple-touch-icon-60x60.png",
      "./icons/apple-touch-icon-57x57.png",
      "./icons/apple-touch-icon-72x72.png",
      "./icons/apple-touch-icon-76x76.png",
      "./icons/apple-touch-icon-114x114.png",
      "./icons/apple-touch-icon-120x120.png",
      "./icons/apple-touch-icon-144x144.png",
      "./icons/apple-touch-icon-152x152.png",
      "./icons/apple-touch-icon-167x167.png",
      "./icons/apple-touch-icon-180x180.png",
      "./icons/apple-touch-icon.png",
      "./icons/apple-touch-icon-precomposed.png",
      "./icons/android-chrome-36x36.png",
      "./icons/android-chrome-48x48.png",
      "./icons/android-chrome-72x72.png",
      "./icons/android-chrome-96x96.png",
      "./icons/android-chrome-144x144.png",
      "./icons/android-chrome-192x192.png",
      "./icons/android-chrome-256x256.png",
      "./icons/android-chrome-384x384.png",
      "./icons/android-chrome-512x512.png",
      "./icons/favicon-16x16.png",
      "./icons/favicon-32x32.png",
      "./icons/favicon.ico",
      "./icons/mstile-70x70.png",
      "./icons/mstile-144x144.png",
      "./icons/mstile-150x150.png",
      "./icons/mstile-310x150.png",
      "./icons/mstile-310x310.png",
      "./icons/apple-touch-startup-image-320x460.png",
      "./icons/apple-touch-startup-image-640x920.png",
      "./icons/apple-touch-startup-image-640x1096.png",
      "./icons/apple-touch-startup-image-748x1024.png",
      "./icons/apple-touch-startup-image-750x1294.png",
      "./icons/apple-touch-startup-image-768x1004.png",
      "./icons/apple-touch-startup-image-1182x2208.png",
      "./icons/apple-touch-startup-image-1242x2148.png",
      "./icons/apple-touch-startup-image-1496x2048.png",
      "./icons/apple-touch-startup-image-1536x2008.png",
      "./icons/firefox_app_60x60.png",
      "./icons/firefox_app_128x128.png",
      "./icons/firefox_app_512x512.png",
      "./icons/manifest.json",
      "./icons/browserconfig.xml",
      "./icons/manifest.webapp",
      "./img/gairai_icon.png",
      "./img/nyuuinn_icon.png",
      "./img/sango_icon.png",
      "./img/annzenn_icon.png",
      "./img/logo.png",
      "./img/howto.png",
      "./img/1-1.png",
      "./img/1-2.png",
      "./img/1-3.png",
      "./img/1-4.png",
      "./img/1-5.png",
      "./img/1-6.png",
      "./img/1-7.png",
      "./img/1-8.png",
      "./img/1-8-1.png",
      "./img/1-9.png",
      "./img/2-1.png",
      "./img/2-2.png",
      "./img/2-3-1.png",
      "./img/2-3-2.png",
      "./img/2-4.png",
      "./img/2-4-1.png",
      "./img/2-5.png",
      "./img/2-6.png",
      "./img/2-7.png",
      "./img/3-1.png",
      "./img/3-1-1.png",
      "./img/3-1-2.png",
      "./img/3-1-3.png",
      "./img/3-1-4.png",
      "./img/3-2.png",
      "./img/3-2-1.png",
      "./img/3-3.png",
      "./img/3-3-1.png",
      "./img/4-1.png",
      "./img/4-2.png",
      "./webpack-bundle.css",
      "./webpack-bundle.js",
      "./",
      "./404.html",
      "./index.html"
    ],
    additional: ["./index.html"],
    optional: []
  },
  externals: [],
  hashesMap: {
    "014aa3ef72cf2d84ee3776f0672b7e71e477463c": "./img/tris-package.svg",
    "692af2283e45adcdfdcdeddc906c22c79af11f41":
      "./icons/apple-touch-icon-60x60.png",
    "3c0f07bfb868136b0f3149f5e973eafdc69ca2a1":
      "./icons/apple-touch-icon-57x57.png",
    "702b092ad7c3d800b3798a959b67c124e2e4f62b":
      "./icons/android-chrome-72x72.png",
    a1ad80f3c08e69a4cfe9332e98bbbc8e648eb58c:
      "./icons/apple-touch-icon-76x76.png",
    "8148f344d7e35ec2881d3b676b0ea0c65a49bdf2":
      "./icons/apple-touch-icon-114x114.png",
    f9733132b115eafb39d99255357f32fc62ac3034:
      "./icons/apple-touch-icon-120x120.png",
    "4f8f8a8538f42a264fd6913f2a25b2c1b556ef03": "./icons/mstile-144x144.png",
    "0a00ffd16dec102224f71d08fa7ddee10c450882":
      "./icons/apple-touch-icon-152x152.png",
    "188f633bf9846d6e4e5a155e21632ae71d96c7fd":
      "./icons/apple-touch-icon-167x167.png",
    a487b7ead29b1adb011a35dbb0e9a61615e81a20:
      "./icons/apple-touch-icon-precomposed.png",
    "3ad6ca08adde375aaf81a8f8c2d6ec986c104d02":
      "./icons/android-chrome-36x36.png",
    "14547d8f7eb2ddd26461adf11bf557b14611b605":
      "./icons/android-chrome-48x48.png",
    "921a03755170791be5f0efccd036a3f14c4deff6":
      "./icons/android-chrome-96x96.png",
    "852f89d50223a389aacaa266ccaf0a8933ffbb68":
      "./icons/android-chrome-192x192.png",
    "1f7c8178bc62d40d9dcdfe587dd4cb18150329e8":
      "./icons/android-chrome-256x256.png",
    "4ad4d89cbeec8309956aefc2e7bf224daab449e5":
      "./icons/android-chrome-384x384.png",
    "77d34213fec2f98356b8a2ca492a6fbcf968a29d":
      "./icons/android-chrome-512x512.png",
    e6edd51012db55e0c1a0fb96fbdcc0a5abddfcf6: "./icons/favicon-16x16.png",
    "98f280277d459715bfad929cf1855445649854ec": "./icons/favicon-32x32.png",
    "65b2f841a789577ccad654855990dc9aedc9f789": "./icons/favicon.ico",
    "5bc82a3d65c7dc259cde843dc816d9365aba85b7": "./icons/mstile-70x70.png",
    cee6aa20598b5fc59fb07f00dac969c6be4609a8: "./icons/mstile-150x150.png",
    "72e9bc6bfcbc7edca9af07073bd3dfbd2b65277f": "./icons/mstile-310x150.png",
    fdeea6b51da72734d9a2fc5b3dc221482c454462: "./icons/mstile-310x310.png",
    "531266da6d8dc76e85e36d55ca391ee9dc5eda73":
      "./icons/apple-touch-startup-image-320x460.png",
    bccb05ae0868ea5261ddd9e7afbd109ff126c111:
      "./icons/apple-touch-startup-image-640x920.png",
    ee52248e33c09ff3066402d78e46b7acfe00568d:
      "./icons/apple-touch-startup-image-640x1096.png",
    d4b39bc8dc9a2a7a5004457386e65ca6253c3536:
      "./icons/apple-touch-startup-image-748x1024.png",
    "69c505d72e180a9024872d52ee17a1386b881c8b":
      "./icons/apple-touch-startup-image-750x1294.png",
    "3c74a6a757e3518422f443632080514d6bf812e0":
      "./icons/apple-touch-startup-image-768x1004.png",
    "19079cb667fe94662aff62cbb8285495f7b671e3":
      "./icons/apple-touch-startup-image-1182x2208.png",
    "0a500f1caed19fa474718a8abe40bdf31e034119":
      "./icons/apple-touch-startup-image-1242x2148.png",
    "9b2aba66d2e7d56ecc59e79d356be72472db898d":
      "./icons/apple-touch-startup-image-1496x2048.png",
    "41f66c1959da2abb000a10388f1958a367d2af3d":
      "./icons/apple-touch-startup-image-1536x2008.png",
    "30629c8471fad14196cf040f490509bf12e31888": "./icons/firefox_app_60x60.png",
    "154500b88e4f26d98f94d0cb8e6d8feec6dedc62":
      "./icons/firefox_app_128x128.png",
    "7862ed74ecb1099c23236562e5491cdedf4af23a":
      "./icons/firefox_app_512x512.png",
    c9ad292bbc9a4d6ac0a7372cd411306c56177aa1: "./icons/manifest.json",
    "5b4f37d41ff649e9eeeb04ca9cc8b94c6757c986": "./icons/browserconfig.xml",
    cdfbeeab1018af59c6777a20775cbdfccca50f75: "./icons/manifest.webapp",
    a0fab6b00709918718a75a1648217b93becaad9b: "./img/gairai_icon.png",
    e56a764aecd444a3fe2de1f0244ab59ba0ddb39e: "./img/nyuuinn_icon.png",
    c5cebeeea6453f8c495666831aa0dcc9b972b90e: "./img/sango_icon.png",
    "136cf0a90cfc3de9fddcdddc5e9a125d257e5394": "./img/annzenn_icon.png",
    "9e24c56037b4c5a0d944a298fe70d169513e5014": "./img/logo.png",
    "82e4795bd822ddd3f6842390ccae22698b6af8eb": "./img/howto.png",
    "2b35ed2a7bdf8a1625b948c3e4bd5800b4da2343": "./img/1-1.png",
    "3930464a6bd7b3120bdb9f45cbf848d59d42f131": "./img/1-2.png",
    fb68079c99dc7a20445338df516ebd4f607923c7: "./img/1-3.png",
    "4c966ba4b1be41a0a73a87b4a2b98a22e3935cef": "./img/1-4.png",
    "5f529c88bf93278b6c9b3c0537bd21ab4ea6db35": "./img/1-5.png",
    "4ae8d219e22b49d42be135bbe23ac046014f1c97": "./img/1-6.png",
    "85b9e92b1b5ce5ea4f116e164fa462331ea336a3": "./img/1-7.png",
    "76db9a792625e6e3370ecc3969f0f238ac02c7de": "./img/1-8.png",
    c892a4ebaa27d7da16f00a31251ae619dedaae82: "./img/1-8-1.png",
    "850a6be98ceedee2a8d6a4cd2662e25cac32ae76": "./img/1-9.png",
    "5ea202cf453200873c9ffc5427eea334140b4d8c": "./img/2-1.png",
    c0464f656689e3a9f9f262a1a18c7edec7f40e85: "./img/2-2.png",
    da2494ce33f00f49cd45acb1eea4fff6102366f7: "./img/2-3-1.png",
    "58bc15c5db1097bf535cb959395034d9cfaedaa5": "./img/2-3-2.png",
    f368a28b05ef8bf5d7f22ace80b06ca336d48c18: "./img/2-4.png",
    "9ea7620e8f3c32a1e7920534ec6083819ee3eea0": "./img/2-4-1.png",
    "2aeb218277377dfa1d7969a77e252aea0c6e243b": "./img/2-5.png",
    "4a7911a96b373beb941a3d76c83aa6a017a0e81f": "./img/2-6.png",
    ebdd3992560b09879f49652ae993947f72d6096c: "./img/2-7.png",
    b855b716a296222ad3e46b147d934415203222a7: "./img/3-1.png",
    f0fcc19f3db1c52a02fc6eb3ac90cce8358b0014: "./img/3-1-1.png",
    "210d5785f8b20c646149036a45cc109b90b9191b": "./img/3-1-2.png",
    "2a9e9a046b923ff86aeed827d2130fcc37481c48": "./img/3-1-3.png",
    "61004682fb33a8ef513a15408538a3357eeb95f8": "./img/3-1-4.png",
    "95b29e5c6525dcfc480f79de8d2daafa36c6e7c9": "./img/3-2.png",
    e3e10678cc30deaa818535bbdf4b5edff85fa2e5: "./img/3-2-1.png",
    b20ae9cc58de9ce544053165f6a0f45629abccf0: "./img/3-3.png",
    "3515e492b299e3286aaa350e7a294eaf19400d9a": "./img/3-3-1.png",
    bef5779b2684972a491e7cf2b69f1224d692db5f: "./img/4-1.png",
    "09d2cd4fc230ed51d01fe2befedff259c2638454": "./img/4-2.png",
    "9085b1a977009d905c1b8d1450553aa34add8bb3": "./webpack-bundle.css",
    "8b9efd8378334d8ea4c5dcc210fb2abf7a340b77": "./webpack-bundle.js",
    "69e35fbd66211b7da69a6d234b15953f099f6342": "./",
    "83e70bfc8c3e0428c79cc0fe0560ade8b58cedc7": "./404.html"
  },
  strategy: "changed",
  responseStrategy: "network-first",
  version: "2019-6-07 14:55:15",
  name: "webpack-offline",
  pluginVersion: "5.0.6",
  relativePaths: true
};

self.addEventListener("fetch", function(event) {});
self.addEventListener("push", function(event) {
  //送られたプッシュ通知の本文を表示
  if (Notification.permission == "granted") {
    console.log("Push Notification Recieved", event);
    event.waitUntil(
      self.registration
        .showNotification(event.data.json().notification.title, {
          body: event.data.json().notification.body,
          icon: event.data.json().notification.icon
        })
        .then(
          function(showEvent) {},
          function(error) {
            console.log(error);
          }
        )
    );
  }
});

// importScripts('https://www.gstatic.com/firebasejs/4.8.1/firebase-app.js');
// importScripts('https://www.gstatic.com/firebasejs/4.8.1/firebase-messaging.js');

// firebase.initializeApp({
//   'messagingSenderId': '961587936477'
// });
// const messaging = firebase.messaging();

// messaging.setBackgroundMessageHandler(function(payload) {
//   console.log('[SW] Received background message ', payload)
//   // Customize notification here
//   const notification = payload.data
//   const notificationTitle = notification.title
//   const notificationOptions = {
//     body: notification.body,
//     icon: notification.icon,
//     badge: '/icons/nfavicon-16x16.png',
//     tag: 'exampleTag',
//     vibrate: [150,100,150,100,200]
//   }
//   console.log('icon:' + notification.icon);

//   return self.registration.showNotification(notificationTitle,
//       notificationOptions)
// })

/******/ (function(modules) {
  // webpackBootstrap
  /******/ // The module cache
  /******/ var installedModules = {}; // The require function
  /******/
  /******/ /******/ function __webpack_require__(moduleId) {
    /******/
    /******/ // Check if module is in cache
    /******/ if (installedModules[moduleId]) {
      /******/ return installedModules[moduleId].exports;
      /******/
    } // Create a new module (and put it into the cache)
    /******/ /******/ var module = (installedModules[moduleId] = {
      /******/ i: moduleId,
      /******/ l: false,
      /******/ exports: {}
      /******/
    }); // Execute the module function
    /******/
    /******/ /******/ modules[moduleId].call(
      module.exports,
      module,
      module.exports,
      __webpack_require__
    ); // Flag the module as loaded
    /******/
    /******/ /******/ module.l = true; // Return the exports of the module
    /******/
    /******/ /******/ return module.exports;
    /******/
  } // expose the modules object (__webpack_modules__)
  /******/
  /******/
  /******/ /******/ __webpack_require__.m = modules; // expose the module cache
  /******/
  /******/ /******/ __webpack_require__.c = installedModules; // define getter function for harmony exports
  /******/
  /******/ /******/ __webpack_require__.d = function(exports, name, getter) {
    /******/ if (!__webpack_require__.o(exports, name)) {
      /******/ Object.defineProperty(exports, name, {
        enumerable: true,
        get: getter
      });
      /******/
    }
    /******/
  }; // define __esModule on exports
  /******/
  /******/ /******/ __webpack_require__.r = function(exports) {
    /******/ if (typeof Symbol !== "undefined" && Symbol.toStringTag) {
      /******/ Object.defineProperty(exports, Symbol.toStringTag, {
        value: "Module"
      });
      /******/
    }
    /******/ Object.defineProperty(exports, "__esModule", { value: true });
    /******/
  }; // create a fake namespace object // mode & 1: value is a module id, require it // mode & 2: merge all properties of value into the ns // mode & 4: return value when already ns object // mode & 8|1: behave like require
  /******/
  /******/ /******/ /******/ /******/ /******/ /******/ __webpack_require__.t = function(
    value,
    mode
  ) {
    /******/ if (mode & 1) value = __webpack_require__(value);
    /******/ if (mode & 8) return value;
    /******/ if (
      mode & 4 &&
      typeof value === "object" &&
      value &&
      value.__esModule
    )
      return value;
    /******/ var ns = Object.create(null);
    /******/ __webpack_require__.r(ns);
    /******/ Object.defineProperty(ns, "default", {
      enumerable: true,
      value: value
    });
    /******/ if (mode & 2 && typeof value != "string")
      for (var key in value)
        __webpack_require__.d(
          ns,
          key,
          function(key) {
            return value[key];
          }.bind(null, key)
        );
    /******/ return ns;
    /******/
  }; // getDefaultExport function for compatibility with non-harmony modules
  /******/
  /******/ /******/ __webpack_require__.n = function(module) {
    /******/ var getter =
      module && module.__esModule
        ? /******/ function getDefault() {
            return module["default"];
          }
        : /******/ function getModuleExports() {
            return module;
          };
    /******/ __webpack_require__.d(getter, "a", getter);
    /******/ return getter;
    /******/
  }; // Object.prototype.hasOwnProperty.call
  /******/
  /******/ /******/ __webpack_require__.o = function(object, property) {
    return Object.prototype.hasOwnProperty.call(object, property);
  }; // __webpack_public_path__
  /******/
  /******/ /******/ __webpack_require__.p = ""; // Load entry module and return exports
  /******/
  /******/
  /******/ /******/ return __webpack_require__((__webpack_require__.s = 0));
  /******/
})(
  /************************************************************************/
  /******/ [
    /* 0 */
    /***/ function(module, exports, __webpack_require__) {
      "use strict";

      (function() {
        var waitUntil = ExtendableEvent.prototype.waitUntil;
        var respondWith = FetchEvent.prototype.respondWith;
        var promisesMap = new WeakMap();

        ExtendableEvent.prototype.waitUntil = function(promise) {
          var extendableEvent = this;
          var promises = promisesMap.get(extendableEvent);

          if (promises) {
            promises.push(Promise.resolve(promise));
            return;
          }

          promises = [Promise.resolve(promise)];
          promisesMap.set(extendableEvent, promises);

          // call original method
          return waitUntil.call(
            extendableEvent,
            Promise.resolve().then(function processPromises() {
              var len = promises.length;

              // wait for all to settle
              return Promise.all(
                promises.map(function(p) {
                  return p["catch"](function() {});
                })
              ).then(function() {
                // have new items been added? If so, wait again
                if (promises.length != len) return processPromises();
                // we're done!
                promisesMap["delete"](extendableEvent);
                // reject if one of the promises rejected
                return Promise.all(promises);
              });
            })
          );
        };

        FetchEvent.prototype.respondWith = function(promise) {
          this.waitUntil(promise);
          return respondWith.call(this, promise);
        };
      })();
      ("use strict");

      if (typeof DEBUG === "undefined") {
        var DEBUG = false;
      }

      function WebpackServiceWorker(params, helpers) {
        var cacheMaps = helpers.cacheMaps;
        // navigationPreload: true, { map: (URL) => URL, test: (URL) => boolean }
        var navigationPreload = helpers.navigationPreload;

        // (update)strategy: changed, all
        var strategy = params.strategy;
        // responseStrategy: cache-first, network-first
        var responseStrategy = params.responseStrategy;

        var assets = params.assets;

        var hashesMap = params.hashesMap;
        var externals = params.externals;

        var prefetchRequest = params.prefetchRequest || {
          credentials: "same-origin",
          mode: "cors"
        };

        var CACHE_PREFIX = params.name;
        var CACHE_TAG = params.version;
        var CACHE_NAME = CACHE_PREFIX + ":" + CACHE_TAG;

        var PRELOAD_CACHE_NAME = CACHE_PREFIX + "$preload";
        var STORED_DATA_KEY = "__offline_webpack__data";

        mapAssets();

        var allAssets = [].concat(
          assets.main,
          assets.additional,
          assets.optional
        );

        self.addEventListener("install", function(event) {
          console.log("[SW]:", "Install event");
          caches.delete(CACHE_NAME);

          var installing = undefined;

          if (strategy === "changed") {
            installing = cacheChanged("main");
          } else {
            installing = cacheAssets("main");
          }
          event.waitUntil(installing);
          event.waitUntil(self.skipWaiting());
        });

        self.addEventListener("activate", function(event) {
          console.log("[SW]:", "Activate event");

          var activation = cacheAdditional();

          // Delete all assets which name starts with CACHE_PREFIX and
          // is not current cache (CACHE_NAME)
          activation = activation.then(storeCacheData);
          activation = activation.then(deleteObsolete);
          activation = activation.then(function() {
            if (self.clients && self.clients.claim) {
              return self.clients.claim();
            }
          });

          if (navigationPreload && self.registration.navigationPreload) {
            activation = Promise.all([
              activation,
              self.registration.navigationPreload.enable()
            ]);
          }

          event.waitUntil(activation);
        });

        function cacheAdditional() {
          if (!assets.additional.length) {
            return Promise.resolve();
          }

          if (DEBUG) {
            console.log("[SW]:", "Caching additional");
          }

          var operation = undefined;

          if (strategy === "changed") {
            operation = cacheChanged("additional");
          } else {
            operation = cacheAssets("additional");
          }

          // Ignore fail of `additional` cache section
          return operation["catch"](function(e) {
            console.error("[SW]:", "Cache section `additional` failed to load");
          });
        }

        function cacheAssets(section) {
          var batch = assets[section];

          return caches
            .open(CACHE_NAME)
            .then(function(cache) {
              return addAllNormalized(cache, batch, {
                bust: params.version,
                request: prefetchRequest,
                failAll: section === "main"
              });
            })
            .then(function() {
              logGroup("Cached assets: " + section, batch);
            })
            ["catch"](function(e) {
              console.error(e);
              throw e;
            });
        }

        function cacheChanged(section) {
          return getLastCache().then(function(args) {
            if (!args) {
              return cacheAssets(section);
            }

            var lastCache = args[0];
            var lastKeys = args[1];
            var lastData = args[2];

            var lastMap = lastData.hashmap;
            var lastVersion = lastData.version;

            if (!lastData.hashmap || lastVersion === params.version) {
              return cacheAssets(section);
            }

            var lastHashedAssets = Object.keys(lastMap).map(function(hash) {
              return lastMap[hash];
            });

            var lastUrls = lastKeys.map(function(req) {
              var url = new URL(req.url);
              url.search = "";
              url.hash = "";

              return url.toString();
            });

            var sectionAssets = assets[section];
            var moved = [];
            var changed = sectionAssets.filter(function(url) {
              if (
                lastUrls.indexOf(url) === -1 ||
                lastHashedAssets.indexOf(url) === -1
              ) {
                return true;
              }

              return false;
            });

            Object.keys(hashesMap).forEach(function(hash) {
              var asset = hashesMap[hash];

              // Return if not in sectionAssets or in changed or moved array
              if (
                sectionAssets.indexOf(asset) === -1 ||
                changed.indexOf(asset) !== -1 ||
                moved.indexOf(asset) !== -1
              )
                return;

              var lastAsset = lastMap[hash];

              if (lastAsset && lastUrls.indexOf(lastAsset) !== -1) {
                moved.push([lastAsset, asset]);
              } else {
                changed.push(asset);
              }
            });

            logGroup("Changed assets: " + section, changed);
            logGroup("Moved assets: " + section, moved);

            var movedResponses = Promise.all(
              moved.map(function(pair) {
                return lastCache.match(pair[0]).then(function(response) {
                  return [pair[1], response];
                });
              })
            );

            return caches.open(CACHE_NAME).then(function(cache) {
              var move = movedResponses.then(function(responses) {
                return Promise.all(
                  responses.map(function(pair) {
                    return cache.put(pair[0], pair[1]);
                  })
                );
              });

              return Promise.all([
                move,
                addAllNormalized(cache, changed, {
                  bust: params.version,
                  request: prefetchRequest,
                  failAll: section === "main",
                  deleteFirst: section !== "main"
                })
              ]);
            });
          });
        }

        function deleteObsolete() {
          return caches.keys().then(function(keys) {
            var all = keys.map(function(key) {
              if (
                key.indexOf(CACHE_PREFIX) !== 0 ||
                key.indexOf(CACHE_NAME) === 0
              )
                return;

              console.log("[SW]:", "Delete cache:", key);
              return caches["delete"](key);
            });

            return Promise.all(all);
          });
        }

        function getLastCache() {
          return caches.keys().then(function(keys) {
            var index = keys.length;
            var key = undefined;

            while (index--) {
              key = keys[index];

              if (key.indexOf(CACHE_PREFIX) === 0) {
                break;
              }
            }

            if (!key) return;

            var cache = undefined;

            return caches
              .open(key)
              .then(function(_cache) {
                cache = _cache;
                return _cache.match(
                  new URL(STORED_DATA_KEY, location).toString()
                );
              })
              .then(function(response) {
                if (!response) return;

                return Promise.all([cache, cache.keys(), response.json()]);
              });
          });
        }

        function storeCacheData() {
          return caches.open(CACHE_NAME).then(function(cache) {
            var data = new Response(
              JSON.stringify({
                version: params.version,
                hashmap: hashesMap
              })
            );

            return cache.put(
              new URL(STORED_DATA_KEY, location).toString(),
              data
            );
          });
        }

        self.addEventListener("fetch", function(event) {
          // Handle only GET requests
          if (event.request.method !== "GET") {
            return;
          }

          // This prevents some weird issue with Chrome DevTools and 'only-if-cached'
          // Fixes issue #385, also ref to:
          // - https://github.com/paulirish/caltrainschedule.io/issues/49
          // - https://bugs.chromium.org/p/chromium/issues/detail?id=823392
          if (
            event.request.cache === "only-if-cached" &&
            event.request.mode !== "same-origin"
          ) {
            return;
          }

          var url = new URL(event.request.url);
          url.hash = "";

          var urlString = url.toString();

          // Not external, so search part of the URL should be stripped,
          // if it's external URL, the search part should be kept
          if (externals.indexOf(urlString) === -1) {
            url.search = "";
            urlString = url.toString();
          }

          var assetMatches = allAssets.indexOf(urlString) !== -1;
          var cacheUrl = urlString;

          if (!assetMatches) {
            var cacheRewrite = matchCacheMap(event.request);

            if (cacheRewrite) {
              cacheUrl = cacheRewrite;
              assetMatches = true;
            }
          }

          if (!assetMatches) {
            // Use request.mode === 'navigate' instead of isNavigateRequest
            // because everything what supports navigationPreload supports
            // 'navigate' request.mode
            if (event.request.mode === "navigate") {
              // Requesting with fetchWithPreload().
              // Preload is used only if navigationPreload is enabled and
              // navigationPreload mapping is not used.
              if (navigationPreload === true) {
                event.respondWith(fetchWithPreload(event));
                return;
              }
            }

            // Something else, positive, but not `true`
            if (navigationPreload) {
              var preloadedResponse = retrivePreloadedResponse(event);

              if (preloadedResponse) {
                event.respondWith(preloadedResponse);
                return;
              }
            }

            // Logic exists here if no cache match
            return;
          }

          // Cache handling/storing/fetching starts here
          var resource = undefined;

          if (responseStrategy === "network-first") {
            resource = networkFirstResponse(event, urlString, cacheUrl);
          }
          // 'cache-first' otherwise
          // (responseStrategy has been validated before)
          else {
            resource = cacheFirstResponse(event, urlString, cacheUrl);
          }

          event.respondWith(resource);
        });

        self.addEventListener("message", function(e) {
          if (e.data === "updateDESU!") {
            console.log("[SW]delete current cache :" + CACHE_NAME);
            caches.delete(CACHE_NAME); // ブラウザ側(main.js)からSWスクリプト更新時イベントで受け取ったメッセージならキャッシュ削除
          }

          var data = e.data;
          if (!data) return;

          switch (data.action) {
            case "skipWaiting":
              {
                if (self.skipWaiting) {
                  console.log("[SW]skipWaiting message event handler");
                  self.skipWaiting();
                }
              }
              break;
          }
        });

        function cacheFirstResponse(event, urlString, cacheUrl) {
          handleNavigationPreload(event);

          return cachesMatch(cacheUrl, CACHE_NAME).then(function(response) {
            if (response) {
              if (DEBUG) {
                console.log(
                  "[SW]:",
                  "URL [" + cacheUrl + "](" + urlString + ") from cache"
                );
              }

              return response;
            }

            // Load and cache known assets
            var fetching = fetch(event.request).then(function(response) {
              if (!response.ok) {
                if (DEBUG) {
                  console.log(
                    "[SW]:",
                    "URL [" +
                      urlString +
                      "] wrong response: [" +
                      response.status +
                      "] " +
                      response.type
                  );
                }

                return response;
              }

              if (DEBUG) {
                console.log("[SW]:", "URL [" + urlString + "] from network");
              }

              if (cacheUrl === urlString) {
                (function() {
                  var responseClone = response.clone();
                  var storing = caches
                    .open(CACHE_NAME)
                    .then(function(cache) {
                      return cache.put(urlString, responseClone);
                    })
                    .then(function() {
                      console.log("[SW]:", "Cache asset: " + urlString);
                    });

                  event.waitUntil(storing);
                })();
              }

              return response;
            });

            return fetching;
          });
        }

        function networkFirstResponse(event, urlString, cacheUrl) {
          return fetchWithPreload(event)
            .then(function(response) {
              if (response.ok) {
                if (DEBUG) {
                  console.log("[SW]:", "URL [" + urlString + "] from network");
                }

                return response;
              }

              // Throw to reach the code in the catch below
              throw response;
            })
            [
              // This needs to be in a catch() and not just in the then() above
              // cause if your network is down, the fetch() will throw
              "catch"
            ](function(erroredResponse) {
              if (DEBUG) {
                console.log(
                  "[SW]:",
                  "URL [" + urlString + "] from cache if possible"
                );
              }

              return cachesMatch(cacheUrl, CACHE_NAME).then(function(response) {
                if (response) {
                  return response;
                }

                if (erroredResponse instanceof Response) {
                  return erroredResponse;
                }

                // Not a response at this point, some other error
                throw erroredResponse;
                // return Response.error();
              });
            });
        }

        function handleNavigationPreload(event) {
          if (
            navigationPreload &&
            typeof navigationPreload.map === "function" &&
            // Use request.mode === 'navigate' instead of isNavigateRequest
            // because everything what supports navigationPreload supports
            // 'navigate' request.mode
            event.preloadResponse &&
            event.request.mode === "navigate"
          ) {
            var mapped = navigationPreload.map(
              new URL(event.request.url),
              event.request
            );

            if (mapped) {
              storePreloadedResponse(mapped, event);
            }
          }
        }

        // Temporary in-memory store for faster access
        var navigationPreloadStore = new Map();

        function storePreloadedResponse(_url, event) {
          var url = new URL(_url, location);
          var preloadResponsePromise = event.preloadResponse;

          navigationPreloadStore.set(preloadResponsePromise, {
            url: url,
            response: preloadResponsePromise
          });

          var isSamePreload = function isSamePreload() {
            return navigationPreloadStore.has(preloadResponsePromise);
          };

          var storing = preloadResponsePromise.then(function(res) {
            // Return if preload isn't enabled or hasn't happened
            if (!res) return;

            // If navigationPreloadStore already consumed
            // or navigationPreloadStore already contains another preload,
            // then do not store anything and return
            if (!isSamePreload()) {
              return;
            }

            var clone = res.clone();

            // Storing the preload response for later consume (hasn't yet been consumed)
            return caches.open(PRELOAD_CACHE_NAME).then(function(cache) {
              if (!isSamePreload()) return;

              return cache.put(url, clone).then(function() {
                if (!isSamePreload()) {
                  return caches.open(PRELOAD_CACHE_NAME).then(function(cache) {
                    return cache["delete"](url);
                  });
                }
              });
            });
          });

          event.waitUntil(storing);
        }

        function retriveInMemoryPreloadedResponse(url) {
          if (!navigationPreloadStore) {
            return;
          }

          var foundResponse = undefined;
          var foundKey = undefined;

          navigationPreloadStore.forEach(function(store, key) {
            if (store.url.href === url.href) {
              foundResponse = store.response;
              foundKey = key;
            }
          });

          if (foundResponse) {
            navigationPreloadStore["delete"](foundKey);
            return foundResponse;
          }
        }

        function retrivePreloadedResponse(event) {
          var url = new URL(event.request.url);

          if (
            self.registration.navigationPreload &&
            navigationPreload &&
            navigationPreload.test &&
            navigationPreload.test(url, event.request)
          ) {
          } else {
            return;
          }

          var fromMemory = retriveInMemoryPreloadedResponse(url);
          var request = event.request;

          if (fromMemory) {
            event.waitUntil(
              caches.open(PRELOAD_CACHE_NAME).then(function(cache) {
                return cache["delete"](request);
              })
            );

            return fromMemory;
          }

          return cachesMatch(request, PRELOAD_CACHE_NAME).then(function(
            response
          ) {
            if (response) {
              event.waitUntil(
                caches.open(PRELOAD_CACHE_NAME).then(function(cache) {
                  return cache["delete"](request);
                })
              );
            }

            return response || fetch(event.request);
          });
        }

        function mapAssets() {
          Object.keys(assets).forEach(function(key) {
            assets[key] = assets[key].map(function(path) {
              var url = new URL(path, location);

              url.hash = "";

              if (externals.indexOf(path) === -1) {
                url.search = "";
              }

              return url.toString();
            });
          });

          hashesMap = Object.keys(hashesMap).reduce(function(result, hash) {
            var url = new URL(hashesMap[hash], location);
            url.search = "";
            url.hash = "";

            result[hash] = url.toString();
            return result;
          }, {});

          externals = externals.map(function(path) {
            var url = new URL(path, location);
            url.hash = "";

            return url.toString();
          });
        }

        function addAllNormalized(cache, requests, options) {
          var bustValue = options.bust;
          var failAll = options.failAll !== false;
          var deleteFirst = options.deleteFirst === true;
          var requestInit = options.request || {
            credentials: "omit",
            mode: "cors"
          };

          var deleting = Promise.resolve();

          if (deleteFirst) {
            deleting = Promise.all(
              requests.map(function(request) {
                return cache["delete"](request)["catch"](function() {});
              })
            );
          }

          return Promise.all(
            requests.map(function(request) {
              if (bustValue) {
                request = applyCacheBust(request, bustValue);
              }

              return fetch(request, requestInit)
                .then(fixRedirectedResponse)
                .then(
                  function(response) {
                    if (!response.ok) {
                      return { error: true };
                    }

                    return { response: response };
                  },
                  function() {
                    return { error: true };
                  }
                );
            })
          ).then(function(responses) {
            if (
              failAll &&
              responses.some(function(data) {
                return data.error;
              })
            ) {
              return Promise.reject(new Error("Wrong response status"));
            }

            if (!failAll) {
              responses = responses.filter(function(data) {
                return !data.error;
              });
            }

            return deleting.then(function() {
              var addAll = responses.map(function(_ref, i) {
                var response = _ref.response;

                return cache.put(requests[i], response);
              });

              return Promise.all(addAll);
            });
          });
        }

        function matchCacheMap(request) {
          var urlString = request.url;
          var url = new URL(urlString);

          var requestType = undefined;

          if (isNavigateRequest(request)) {
            requestType = "navigate";
          } else if (url.origin === location.origin) {
            requestType = "same-origin";
          } else {
            requestType = "cross-origin";
          }

          for (var i = 0; i < cacheMaps.length; i++) {
            var map = cacheMaps[i];

            if (!map) continue;
            if (
              map.requestTypes &&
              map.requestTypes.indexOf(requestType) === -1
            ) {
              continue;
            }

            var newString = undefined;

            if (typeof map.match === "function") {
              newString = map.match(url, request);
            } else {
              newString = urlString.replace(map.match, map.to);
            }

            if (newString && newString !== urlString) {
              return newString;
            }
          }
        }

        function fetchWithPreload(event) {
          if (!event.preloadResponse || navigationPreload !== true) {
            return fetch(event.request);
          }

          return event.preloadResponse.then(function(response) {
            return response || fetch(event.request);
          });
        }
      }

      function cachesMatch(request, cacheName) {
        return caches
          .match(request, {
            cacheName: cacheName
          })
          .then(function(response) {
            if (isNotRedirectedResponse(response)) {
              return response;
            }

            // Fix already cached redirected responses
            return fixRedirectedResponse(response).then(function(
              fixedResponse
            ) {
              return caches
                .open(cacheName)
                .then(function(cache) {
                  return cache.put(request, fixedResponse);
                })
                .then(function() {
                  return fixedResponse;
                });
            });
          })
          [
            // Return void if error happened (cache not found)
            "catch"
          ](function() {});
      }

      function applyCacheBust(asset, key) {
        var hasQuery = asset.indexOf("?") !== -1;
        return (
          asset +
          (hasQuery ? "&" : "?") +
          "__uncache=" +
          encodeURIComponent(key)
        );
      }

      function isNavigateRequest(request) {
        return (
          request.mode === "navigate" ||
          request.headers.get("Upgrade-Insecure-Requests") ||
          (request.headers.get("Accept") || "").indexOf("text/html") !== -1
        );
      }

      function isNotRedirectedResponse(response) {
        return (
          !response ||
          !response.redirected ||
          !response.ok ||
          response.type === "opaqueredirect"
        );
      }

      // Based on https://github.com/GoogleChrome/sw-precache/pull/241/files#diff-3ee9060dc7a312c6a822cac63a8c630bR85
      function fixRedirectedResponse(response) {
        if (isNotRedirectedResponse(response)) {
          return Promise.resolve(response);
        }

        var body =
          "body" in response ? Promise.resolve(response.body) : response.blob();

        return body.then(function(data) {
          return new Response(data, {
            headers: response.headers,
            status: response.status
          });
        });
      }

      function copyObject(original) {
        return Object.keys(original).reduce(function(result, key) {
          result[key] = original[key];
          return result;
        }, {});
      }

      function logGroup(title, assets) {
        console.groupCollapsed("[SW]:", title);

        assets.forEach(function(asset) {
          console.log("Asset:", asset);
        });

        console.groupEnd();
      }
      WebpackServiceWorker(__wpo, {
        loaders: {},
        cacheMaps: [],
        navigationPreload: true
      });
      module.exports = __webpack_require__(1);

      /***/
    },
    /* 1 */
    /***/ function(module, exports) {
      /***/
    }
    /******/
  ]
);
